# **Testing Framework Overview**

![Screenshot 2024-07-18 032709](https://github.com/user-attachments/assets/ee9ae588-d9ea-4483-a445-e4b5fb12919f)
![Screenshot 2024-07-18 033244](https://github.com/user-attachments/assets/44889f47-ecde-4e0f-8133-712966036232)
![Screenshot 2024-07-18 033537](https://github.com/user-attachments/assets/4b3eb686-59ce-434c-be60-e30c80f26216)

## **Unit Test**
A unit test is a type of software testing that focuses on verifying that individual units or components of software work as intended. A unit is the smallest testable part of an application, such as a function, method, or class. Unit tests are typically automated and written by developers to ensure that each unit of the software performs correctly under various conditions. They help identify bugs early in the development process, making it easier to fix issues before they affect the entire system.

## **Widget Testing**
Widget testing, also known as component testing, is a type of testing in software development, particularly in Flutter, where individual widgets are tested in isolation. This helps ensure that the UI components function as expected.

### **Key Points About Widget Testing**
- **Isolated Environment**: Widgets are tested in a simulated environment to verify their behavior without involving other parts of the app.
- **Efficiency**: Faster than integration tests since they focus on small, individual parts.
- **Verification**: Ensures that the widget looks and behaves as intended, responding correctly to user interactions and state changes.

In Flutter, widget tests are written using the `flutter_test` package, which provides tools for creating, running, and verifying the tests.

## **Integration Test**
An integration test is a type of software testing that focuses on verifying the interactions between different units or components of a software system. Unlike unit tests, which test individual parts in isolation, integration tests ensure that these parts work together correctly. This involves testing the interfaces and the flow of data between modules to identify issues that may arise when components are combined. Integration tests are essential for detecting problems such as mismatched data types, incorrect function calls, and integration-related bugs that unit tests might miss.

## **Golden Test**

![image](https://github.com/user-attachments/assets/a7742842-9ba2-488d-bb5b-50bdc661fbb4)

### **Flutter Golden Test Images**

In Flutter golden tests, several types of images are generated to help validate the visual output of widgets:

- **`counter_masterImage.png`**: The baseline or golden image. This is the reference image that represents the expected correct rendering of the widget.

- **`counter_testimage.png`**: The current image generated by the widget during the test run. This is compared against the baseline image.

- **`counter_isolateDiff.png`**: Shows the differences between the baseline and current test images, highlighting areas where they differ.

- **`counter_maskedDiff.png`**: A diff image with a mask applied to highlight differences in a focused manner, often used to emphasize intentional changes.

These images help ensure that the UI remains consistent and visually correct across different versions of the app.

### **Golden Testing with `golden_toolkit`**

Golden tests ensure that the app's UI remains consistent by comparing the rendered output to a baseline image (the "golden" image). The `golden_toolkit` package offers a streamlined way to manage these tests.

#### **1. Adding `golden_toolkit` Package**
First, add `golden_toolkit` to the `pubspec.yaml`:

```yaml
dev_dependencies:
  golden_toolkit: ^0.15.0
```

In Flutter, the default command to generate or update a golden image is simply running the `flutter test` command. However, to specifically manage golden files, the `--update-goldens` flag can be used. This flag tells the test runner to update the golden images instead of comparing them against the existing ones.

Hereâ€™s the command:

```bash
flutter test --update-goldens
```

#### **2. Configuring Golden Tests**
In the test file, set up the `GoldenToolkit` and write a golden test:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:golden_toolkit/golden_toolkit.dart';

void main() {
  testGoldens('example golden test', (tester) async {
    final widget = Container(
      color: Colors.blue,
      width: 100,
      height: 100,
    );

    await tester.pumpWidgetBuilder(widget);

    await screenMatchesGolden(tester, 'example_golden_test');
  });
}
```

#### **3. Running Golden Tests**
Golden tests can be run using the `flutter test` command. The `screenMatchesGolden` function captures the current state of the widget and compares it to the baseline image. If there are differences, the test will fail, and the diff images can be reviewed to identify the changes.

#### **4. Managing Golden Files**
When creating a golden test, the generated baseline images need to be approved. These images are stored in the project and should be kept under version control. If the UI changes intentionally, the golden images can be updated to reflect the new design.

### **Steps to Generate or Update Golden Images**

1. **Add or Modify a Golden Test**: Write or update a test using the `golden_toolkit` package or any other golden testing method.

2. **Run the Test with the Update Flag**: Use the `flutter test --update-goldens` command to generate new golden images or update existing ones based on the current widget rendering.

3. **Review and Commit**: After running the tests with `--update-goldens`, review the generated or updated golden images to ensure they match the expected design. Once confirmed, commit these images to the version control system.

### **Example Usage**

Suppose there is a golden test in the test file like this:

```dart
testGoldens('example golden test', (tester) async {
  final widget = Container(
    color: Colors.blue,
    width: 100,
    height: 100,
  );

  await tester.pumpWidgetBuilder(widget);
  await screenMatchesGolden(tester, 'example_golden_test');
});
```

Run the following command to generate or update the golden image:

```bash
flutter test --update-goldens
```

This command will generate a new image if one doesn't exist or update the existing golden image with the current rendering of the widget.

## **Logging in Flutter Tests with `logging` Package**

### **1. Setting Up the `logging` Package**
To get started with logging, add the `logging` package to the `pubspec.yaml`:

```yaml
dependencies:
  logging: ^1.2.0
```

### **2. Configuring the Logger**
Create and configure a logger in the test files:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:logging/logging.dart';

void main() {
  // Create a logger
  Logger logger = Logger('TestLogger');

  // Set the root log level to ALL
  Logger.root.level = Level.ALL;

  // Listen to the logger's output
  Logger.root.onRecord.listen((record) {
    print('${record.level.name}: ${record.time}: ${record.message}');
  });

  test('example test with logging', () {
    logger.info('This is an info log message');
    expect(1 + 1, equals(2));
  });
}
```

### **3. Using the Logger**
Different logging levels (`info`, `warning`, `severe`, etc.) can be used to categorize log messages. This helps in filtering logs based on the severity level, making it easier to debug specific issues.

# **JUnit Test Reporting**

JUnit, a testing framework for Java, provides a standard XML format for test reports that can be used in various environments, including Flutter. In Flutter, JUnit-style reports can be generated using the `flutter_test` package and the `junitreport` tool.

### **Setting Up JUnit Reporting**

1. **Install junitreport**: The `junitreport` package converts Flutter test results into JUnit XML format.

    ```yaml
    dev_dependencies:
      junitreport: ^1.0.0
    ```

2. **Generate JUnit XML Report**: Run tests with the `flutter test` command, capturing output in a JSON file, which is then converted to JUnit XML format using the `junitreport` tool.

    ```bash
    flutter test --machine > test/test_output.json
    dart run junitreport:test_output.json -o test/junit
    ```

   This command creates a JUnit XML report in the `test/junit` directory.

# **Integrating JUnit Reporting with Jenkins**

Jenkins can be configured to use JUnit reports for displaying test results, making it easier to track test status and failures.

### **Jenkins Configuration**

1. **Install JUnit Plugin**: Ensure that the JUnit plugin is installed in Jenkins, allowing it to parse JUnit XML reports.

2. **Configure Project**:
   - In the Jenkins job configuration, under "Post-build Actions," select "Publish JUnit test result report."
   - Specify the path to the JUnit XML report, e.g., `test/junit/*.xml`.

3. **Build Triggers**: Jenkins can be configured to trigger builds based on repository changes or on a schedule.

4. **Running Tests**:
   - Add a build step in Jenkins to run the Flutter tests and generate JUnit reports.

   ```bash
   flutter test --machine > test

/test_output.json
   dart run junitreport:test_output.json -o test/junit
   ```

5. **Viewing Results**: Jenkins will display the test results in the "Test Result" section, showing overall test status, individual test case outcomes, and detailed error or failure messages.

### **Example Jenkins Pipeline Configuration**

The following is an example Jenkins pipeline script for a Flutter project that includes test execution and JUnit reporting:

```groovy
pipeline {
    agent any

    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/your-repository.git'
            }
        }

        stage('Install Dependencies') {
            steps {
                sh 'flutter pub get'
            }
        }

        stage('Run Tests') {
            steps {
                sh 'flutter test --machine > test/test_output.json'
                sh 'dart run junitreport:test_output.json -o test/junit'
            }
        }
    }

    post {
        always {
            junit 'test/junit/*.xml'
        }
    }
}
```

This pipeline performs the following steps:
- **Checkout**: Retrieves the code from the repository.
- **Install Dependencies**: Installs necessary Flutter dependencies.
- **Run Tests**: Executes the Flutter tests and generates JUnit XML reports.
- **Post Actions**: Publishes the test results using the JUnit plugin.

This setup provides automated testing and reporting, helping maintain code quality and catching issues early in the development process.
