# Testing

![Screenshot 2024-07-18 032709](https://github.com/user-attachments/assets/ee9ae588-d9ea-4483-a445-e4b5fb12919f)
![Screenshot 2024-07-18 033244](https://github.com/user-attachments/assets/44889f47-ecde-4e0f-8133-712966036232)
![Screenshot 2024-07-18 033537](https://github.com/user-attachments/assets/4b3eb686-59ce-434c-be60-e30c80f26216)

## Unit Test
A unit test is a type of software testing that focuses on verifying that individual units or components of software work as intended. A unit is the smallest testable part of an application, such as a function, method, or class. Unit tests are typically automated and written by developers to ensure that each unit of the software performs correctly under various conditions. They help identify bugs early in the development process, making it easier to fix issues before they affect the entire system.

## Widget Testing
Widget testing, also known as component testing, is a type of testing in software development, particularly in Flutter, where individual widgets are tested in isolation. This helps ensure that the UI components function as expected.

### Key Points About Widget Testing
- **Isolated Environment**: Widgets are tested in a simulated environment to verify their behavior without involving other parts of the app.
- **Efficiency**: Faster than integration tests since they focus on small, individual parts.
- **Verification**: Ensures that the widget looks and behaves as intended, responding correctly to user interactions and state changes.

In Flutter, widget tests are written using the `flutter_test` package, which provides tools for creating, running, and verifying the tests.

## Integration Test
An integration test is a type of software testing that focuses on verifying the interactions between different units or components of a software system. Unlike unit tests, which test individual parts in isolation, integration tests ensure that these parts work together correctly. This involves testing the interfaces and the flow of data between modules to identify issues that may arise when components are combined. Integration tests are essential for detecting problems such as mismatched data types, incorrect function calls, and integration-related bugs that unit tests might miss.

## Golden Test
![image](https://github.com/user-attachments/assets/a7742842-9ba2-488d-bb5b-50bdc661fbb4)

### Flutter Golden Test Images

In Flutter golden tests, several types of images are generated to help you validate the visual output of your widgets:

- **`counter_masterImage.png`**: The baseline or golden image. This is the reference image that represents the expected correct rendering of the widget.

- **`counter_testimage.png`**: The current image generated by the widget during the test run. This is compared against the baseline image.

- **`counter_isolateDiff.png`**: Shows the differences between the baseline and current test images, highlighting areas where they differ.

- **`counter_maskedDiff.png`**: A diff image with a mask applied to highlight differences in a focused manner, often used to emphasize intentional changes.

These images help ensure that your UI remains consistent and visually correct across different versions of your app.

### **Golden Testing with `golden_toolkit`**

Golden tests ensure that your app's UI remains consistent by comparing the rendered output to a baseline image (the "golden" image). The `golden_toolkit` package offers a streamlined way to manage these tests.

#### **1. Adding `golden_toolkit` Package**
First, add `golden_toolkit` to your `pubspec.yaml`:

```yaml
dev_dependencies:
  golden_toolkit: ^0.15.0
```


In Flutter, the default command to generate or update a golden image is simply running the `flutter test` command. However, to specifically manage golden files, you can use the `--update-goldens` flag. This flag tells the test runner to update the golden images instead of comparing against the existing ones.

Hereâ€™s the command:

```bash
flutter test --update-goldens
```

### Steps to Generate or Update Golden Images

1. **Add or Modify a Golden Test**: Write or update a test using the `golden_toolkit` package or any other golden testing method.

2. **Run the Test with the Update Flag**: Use the `flutter test --update-goldens` command to generate new golden images or update existing ones based on the current widget rendering.

3. **Review and Commit**: After running the tests with `--update-goldens`, review the generated or updated golden images to ensure they match the expected design. Once confirmed, commit these images to your version control system.

### Example Usage

Suppose you have a golden test in your test file like this:

```dart
testGoldens('example golden test', (tester) async {
  final widget = Container(
    color: Colors.blue,
    width: 100,
    height: 100,
  );

  await tester.pumpWidgetBuilder(widget);
  await screenMatchesGolden(tester, 'example_golden_test');
});
```

Run the following command to generate or update the golden image:

```bash
flutter test --update-goldens
```

This command will generate a new image if one doesn't exist or update the existing golden image with the current rendering of the widget.

#### **2. Configuring Golden Tests**
In your test file, set up the `GoldenToolkit` and write a golden test:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:golden_toolkit/golden_toolkit.dart';

void main() {
  testGoldens('example golden test', (tester) async {
    final widget = Container(
      color: Colors.blue,
      width: 100,
      height: 100,
    );

    await tester.pumpWidgetBuilder(widget);

    await screenMatchesGolden(tester, 'example_golden_test');
  });
}
```

#### **3. Running Golden Tests**
Golden tests can be run using the `flutter test` command. The `screenMatchesGolden` function captures the current state of the widget and compares it to the baseline image. If there are differences, the test will fail, and you can review the diff images to identify the changes.

#### **4. Managing Golden Files**
When you first create a golden test, you'll need to approve the generated baseline images. These images are stored in your project and should be kept under version control. If the UI changes intentionally, you can update the golden images to reflect the new design.


### **Logging in Flutter Tests with `logging` Package**

#### **1. Setting Up the `logging` Package**
To get started with logging, add the `logging` package to your `pubspec.yaml`:

```yaml
dependencies:
  logging: ^1.2.0
```

#### **2. Configuring the Logger**
Create and configure a logger in your test files:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:logging/logging.dart';

void main() {
  // Create a logger
  Logger logger = Logger('TestLogger');

  // Set the root log level to ALL
  Logger.root.level = Level.ALL;

  // Listen to the logger's output
  Logger.root.onRecord.listen((record) {
    print('${record.level.name}: ${record.time}: ${record.message}');
  });

  test('example test with logging', () {
    logger.info('This is an info log message');
    expect(1 + 1, equals(2));
  });
}
```

#### **3. Using the Logger**
You can use different logging levels (`info`, `warning`, `severe`, etc.) to categorize your log messages. This helps in filtering logs based on the severity level, making it easier to debug specific issues.
